diff --git a/kernel/defs.h b/kernel/defs.h
index 59f7aae..794adc1 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -92,6 +92,7 @@ int             fork(void);
 int             growproc(int);
 pagetable_t     proc_pagetable(struct proc *);
 void            proc_freepagetable(pagetable_t, uint64);
+void            proc_freepagetable_new(pagetable_t);
 int             kill(int);
 struct cpu*     mycpu(void);
 struct cpu*     getmycpu(void);
@@ -179,6 +180,14 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 int             test_pagetable();
+void            vmprint(pagetable_t);
+void            k_kvmmap(pagetable_t, uint64, uint64, uint64, int);
+pagetable_t     k_kvminit(void);
+void            sync_pagetable(pagetable_t, pagetable_t, uint64, uint64);
+
+//vmcopyin.c
+int             copyin_new(pagetable_t, char *, uint64, uint64);
+int             copyinstr_new(pagetable_t, char *, uint64, uint64);
 
 // plic.c
 void            plicinit(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index 7b8a524..c8778cb 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -96,7 +96,9 @@ int exec(char *path, char **argv) {
   p->trapframe->epc = elf.entry;  // initial program counter = main
   p->trapframe->sp = sp;          // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
-
+  sync_pagetable(p->k_pagetable, p->pagetable, 0, p->sz);
+  //print pagetable 
+  if(p->pid==1) vmprint(p->pagetable);
   return argc;  // this ends up in a0, the first argument to main(argc, argv)
 
 bad:
diff --git a/kernel/proc.c b/kernel/proc.c
index 292ccb8..c305ea5 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -37,6 +37,7 @@ void procinit(void) {
     uint64 va = KSTACK((int)(p - proc));
     kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
     p->kstack = va;
+    p->kstack_pa = (uint64)pa;
   }
   kvminithart();
 }
@@ -111,6 +112,9 @@ found:
     return 0;
   }
 
+  p->k_pagetable = k_kvminit();
+  k_kvmmap(p->k_pagetable,p->kstack,p->kstack_pa,PGSIZE,PTE_R|PTE_W);
+
   // Set up new context to start executing at forkret,
   // which returns to user space.
   memset(&p->context, 0, sizeof(p->context));
@@ -127,7 +131,9 @@ static void freeproc(struct proc *p) {
   if (p->trapframe) kfree((void *)p->trapframe);
   p->trapframe = 0;
   if (p->pagetable) proc_freepagetable(p->pagetable, p->sz);
+  if(p->k_pagetable) proc_freepagetable_new(p->k_pagetable);
   p->pagetable = 0;
+  p->k_pagetable = 0;
   p->sz = 0;
   p->pid = 0;
   p->parent = 0;
@@ -174,6 +180,20 @@ void proc_freepagetable(pagetable_t pagetable, uint64 sz) {
   uvmfree(pagetable, sz);
 }
 
+void proc_freepagetable_new(pagetable_t pagetable) {
+  // there are 2^9 = 512 PTEs in a page table.
+  for (int i = 0; i < 512; i++) {
+    pte_t pte = pagetable[i];
+    if ((pte & PTE_V) && (pte & (PTE_R | PTE_W | PTE_X)) == 0) {
+      // this PTE points to a lower-level page table.
+      uint64 child = PTE2PA(pte);
+      proc_freepagetable_new((pagetable_t)child);
+      pagetable[i] = 0;
+    }
+  }
+  kfree((void *)pagetable);
+}
+
 // a user program that calls exec("/init")
 // od -t xC initcode
 uchar initcode[] = {0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02, 0x97, 0x05, 0x00, 0x00, 0x93,
@@ -193,6 +213,8 @@ void userinit(void) {
   uvminit(p->pagetable, initcode, sizeof(initcode));
   p->sz = PGSIZE;
 
+  sync_pagetable(p->k_pagetable, p->pagetable, 0, 1);
+
   // prepare for the very first "return" from kernel to user.
   p->trapframe->epc = 0;      // user program counter
   p->trapframe->sp = PGSIZE;  // user stack pointer
@@ -216,6 +238,7 @@ int growproc(int n) {
     if ((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
       return -1;
     }
+    sync_pagetable(p->k_pagetable, p->pagetable, sz-n, sz);
   } else if (n < 0) {
     sz = uvmdealloc(p->pagetable, sz, sz + n);
   }
@@ -256,6 +279,8 @@ int fork(void) {
     if (p->ofile[i]) np->ofile[i] = filedup(p->ofile[i]);
   np->cwd = idup(p->cwd);
 
+  sync_pagetable(np->k_pagetable, np->pagetable, 0, np->sz);
+
   safestrcpy(np->name, p->name, sizeof(p->name));
 
   pid = np->pid;
@@ -430,8 +455,10 @@ void scheduler(void) {
         // before jumping back to us.
         p->state = RUNNING;
         c->proc = p;
+        w_satp(MAKE_SATP(p->k_pagetable));
+        sfence_vma();
         swtch(&c->context, &p->context);
-
+        
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         c->proc = 0;
@@ -440,6 +467,7 @@ void scheduler(void) {
       }
       release(&p->lock);
     }
+    if(found == 0)  kvminithart();
 #if !defined(LAB_FS)
     if (found == 0) {
       intr_on();
diff --git a/kernel/proc.h b/kernel/proc.h
index 9c16ea7..4bb9707 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -103,4 +103,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  pagetable_t k_pagetable;     //Kernel pagetable
+  uint64 kstack_pa;            //Physical address of kernel stack
 };
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 5fbd4e0..3e8db06 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -365,3 +365,5 @@ sfence_vma()
 
 typedef uint64 pte_t;
 typedef uint64 *pagetable_t; // 512 PTEs
+
+#define SSTATUS_SUM (1L << 18)
\ No newline at end of file
diff --git a/kernel/vm.c b/kernel/vm.c
index b794885..29d36f2 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -316,6 +316,10 @@ int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
 // Copy len bytes to dst from virtual address srcva in a given page table.
 // Return 0 on success, -1 on error.
 int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
+  w_sstatus(r_sstatus() | SSTATUS_SUM);
+  int res = copyin_new(pagetable,dst,srcva,len);
+  w_sstatus(r_sstatus() & ~SSTATUS_SUM);
+  return res;
   uint64 n, va0, pa0;
 
   while (len > 0) {
@@ -338,6 +342,10 @@ int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
 // until a '\0', or max.
 // Return 0 on success, -1 on error.
 int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) {
+  w_sstatus(r_sstatus() | SSTATUS_SUM);
+  int res = copyinstr_new(pagetable,dst,srcva,max);
+  w_sstatus(r_sstatus() & ~SSTATUS_SUM);
+  return res;
   uint64 n, va0, pa0;
   int got_null = 0;
 
@@ -378,4 +386,84 @@ int test_pagetable() {
   uint64 gsatp = MAKE_SATP(kernel_pagetable);
   printf("test_pagetable: %d\n", satp != gsatp);
   return satp != gsatp;
-}
\ No newline at end of file
+}
+
+void print_helper(pagetable_t pagetable,int level,uint64 va){
+  for(int i = 0;i < 512;i ++){
+    pte_t pte = pagetable[i];
+    if(pte & PTE_V){
+      char flags[5] = "----";
+      uint flag = PTE_FLAGS(pte);
+      if(flag & PTE_R)  flags[0] = 'r';
+      if(flag & PTE_W)  flags[1] = 'w';
+      if(flag & PTE_X)  flags[2] = 'x';
+      if(flag & PTE_U)  flags[3] = 'u';
+      uint64 pa = PTE2PA(pte);
+      if(level == 2){
+        printf("||idx: %d: pa: %p, flags: %s\n",i,pa,flags);
+        print_helper((pagetable_t)pa,level-1,i << 30);
+      }else if(level){
+        printf("||   ||idx: %d: pa: %p, flags: %s\n",i,pa,flags);
+        print_helper((pagetable_t)pa,level-1,va | (i << 21));
+      }else{
+        printf("||   ||   ||idx: %d: va: %p -> pa: %p, flags: %s\n",i,(va | (i << 12) | (pa & 0xFFF))&0x3FFFFFFFFF,pa,flags);
+      }
+    }
+  }
+}
+
+//print pagetable
+void vmprint(pagetable_t pagetable){
+  printf("page table %p\n",pagetable);
+  print_helper(pagetable,2,0);
+}
+
+// add a mapping to the kernel page table.
+// only used when booting.
+// does not flush TLB or enable paging.
+void k_kvmmap(pagetable_t pagetable,uint64 va, uint64 pa, uint64 sz, int perm) {
+  if (mappages(pagetable, va, sz, pa, perm) != 0) panic("kvmmap");
+}
+
+/*
+ * create a new direct-map page table for the kernel and return.
+ */
+pagetable_t k_kvminit() {
+  pagetable_t k_pagetable = (pagetable_t)kalloc();
+  memset(k_pagetable, 0, PGSIZE);
+
+  // uart registers
+  k_kvmmap(k_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+
+  // virtio mmio disk interface
+  k_kvmmap(k_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+
+  // // CLINT
+  // kvmmap(CLINT, CLINT, 0x10000, PTE_R | PTE_W);
+
+  // PLIC
+  k_kvmmap(k_pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+
+  // map kernel text executable and read-only.
+  k_kvmmap(k_pagetable, KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);
+
+  // map kernel data and the physical RAM we'll make use of.
+  k_kvmmap(k_pagetable, (uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);
+
+  // map the trampoline for trap entry/exit to
+  // the highest virtual address in the kernel.
+  k_kvmmap(k_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+
+  return k_pagetable;
+}
+
+void sync_pagetable(pagetable_t k_pagetable, pagetable_t u_pagetable, uint64 start, uint64 end){
+  pte_t *pte;
+  pte_t *k_pte;
+  for (int i = start; i < end; i+=PGSIZE) {
+    pte = walk(u_pagetable, i, 0);
+    k_pte = walk(k_pagetable, i, 1);
+    *k_pte = (*pte) & (~PTE_U);
+  }
+}
+
